<?php

/*
 *
 *                            _____      _
 *     /\                    |  __ \    | |
 *    /  \   __ _ _   _  __ _| |__) |___| | __ _ _   _
 *   / /\ \ / _` | | | |/ _` |  _  // _ \ |/ _` | | | |
 *  / ____ \ (_| | |_| | (_| | | \ \  __/ | (_| | |_| |
 * /_/    \_\__, |\__,_|\__,_|_|  \_\___|_|\__,_|\__, |
 *               |_|                              |___/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author AquaRelay Team
 * @link https://www.aquarelay.dev/
 *
 */

declare(strict_types=1);

namespace aquarelay\network\handler\downstream;

use aquarelay\event\default\player\PlayerJoinEvent;
use pocketmine\network\mcpe\protocol\AvailableCommandsPacket;
use pocketmine\network\mcpe\protocol\DisconnectPacket;
use pocketmine\network\mcpe\protocol\PlayStatusPacket;
use pocketmine\network\mcpe\protocol\RequestChunkRadiusPacket;
use pocketmine\network\mcpe\protocol\StartGamePacket;
use pocketmine\network\mcpe\protocol\TransferPacket;
use pocketmine\network\mcpe\protocol\types\command\raw\CommandEnumRawData;
use pocketmine\network\mcpe\protocol\types\command\raw\CommandOverloadRawData;
use pocketmine\network\mcpe\protocol\types\command\raw\CommandParameterRawData;
use pocketmine\network\mcpe\protocol\types\command\raw\CommandRawData;
use function array_search;
use function count;
use function strtolower;
use function ucfirst;

class DownstreamInGameHandler extends AbstractDownstreamPacketHandler
{

	public function handleAvailableCommands(AvailableCommandsPacket $packet) : bool
	{
		$player = $this->getPlayer();
		$server = $player->getServer();

		if (!$server->getConfig()->getMiscSettings()->getCommandInjection()){
			return true;
		}

		$commandMap = $server->getCommandMap();

		$added = [];

		foreach ($commandMap->getCommands() as $command) {
			$name = strtolower($command->getName());

			if (isset($added[$name])) {
				continue;
			}

			if (!$command->testPermission($player)) {
				continue;
			}

			if ($command->getName() === "help") {
				continue;
			}

			$aliasIndexes = [];
			$aliases = $command->getAliases();
			$aliases[] = $name;

			foreach ($aliases as $alias) {
				$alias = strtolower($alias);

				if ($alias === "help") {
					continue;
				}

				$index = array_search($alias, $packet->enumValues, true);
				if ($index === false) {
					$packet->enumValues[] = $alias;
					$index = count($packet->enumValues) - 1;
				}

				$aliasIndexes[] = $index;
			}

			$enumIndex = -1;

			if ($aliasIndexes !== []) {
				$packet->enums[] = new CommandEnumRawData(
					ucfirst($name) . "Aliases",
					$aliasIndexes
				);

				$enumIndex = count($packet->enums) - 1;
			}

			$packet->commandData[] = new CommandRawData(
				$name,
				$command->getBuilder()->getDescription(),
				0,
				"any",
				$enumIndex,
				[],
				[
					new CommandOverloadRawData(false, [
						new CommandParameterRawData(
							"args",
							1048646,
							true,
							0)
					]) // TODO: what this magic typeInfo could be?
				]
			);

			$added[$name] = true;
		}

		return true;
	}

	public function handleStartGame(StartGamePacket $packet) : bool
	{
		$chunkRadiusPacket = new RequestChunkRadiusPacket();
		$chunkRadiusPacket->radius = 8;
		$chunkRadiusPacket->maxRadius = 8;

		$this->getPlayer()->getDownstream()->sendGamePacket($chunkRadiusPacket);
		$this->getPlayer()->backendRuntimeId = $packet->actorRuntimeId;

		return true;
	}

	public function handlePlayStatus(PlayStatusPacket $packet) : bool
	{
		if ($packet->status === PlayStatusPacket::LOGIN_SUCCESS) {
			$this->getPlayer()->getNetworkSession()->debug('Forwarding LOGIN_SUCCESS from backend to client');
			return true;
		}
		if ($packet->status === PlayStatusPacket::PLAYER_SPAWN) {
			if ($this->getPlayer()->backendRuntimeId === null) {
				$this->getPlayer()->getNetworkSession()->debug('Cannot send spawn notification: backendRuntimeId is null.');
			} else {
				$this->getPlayer()->getNetworkSession()->debug('Sending spawn notification, waiting for spawn response');
				$event = new PlayerJoinEvent($this->getPlayer());
				$event->call();
			}
		}

		return true;
	}

	public function handleTransfer(TransferPacket $packet) : bool
	{
		$serverManager = $this->getPlayer()->getServer()->getServerManager();
		$ipAddress = $packet->address;

		$server = $serverManager->get($ipAddress);
		if ($server !== null){
			$this->getPlayer()->transferToBackend($server);
			return true;
		}

		$port = $packet->port;

		foreach ($serverManager->getAll() as $data) {
			if ($data->getAddress() === $ipAddress && $data->getPort() === $port) {
				$this->getPlayer()->transferToBackend($serverManager->get($data->getName()));
				break;
			}
		}

		return true;
	}

	public function handleDisconnect(DisconnectPacket $packet) : bool
	{
		$this->getPlayer()->tryFallbackOrDisconnect();
		return true;
	}
}
